REGLAGE ODO et ASSERVE

!!! Commencer par régler l'odométrie avant l'asserve !!!

REGLAGE ODO

	Il y a deux coefficients à régler (trois en réalité mais il y en a un qui est l'inverse de l'autre) :
	- le nombre de tics de roue codeuse par mètre
	- son inverse
	- la distance entre les roues codeuses en mètre

	!!! Commencer par régler le nombre de tics par mètre !!!

		Réglage du nombre de tics par mètre N

		Première estimation : 
		- mesurer le diamètre des roues codeuses avec un pied à coulisse et en déduire le périmètre P
		- on connait le nombre de tics par tour N_tics des roues (2048 pour les CUI AMT10), on fait un petit produit en croix et on a une première estimation : N = N_tics / P
		- calculer son inverse et rentrer les 2 coeffs dans lib_asserv_default

		Affinage
		- mettre le pic en mode debug pour pouvoir lire la distance parcourue
		- coller le robot contre un mur et faire odo_init() pour initialiser l'odo à (0,0,0)
		- faire parcourir la distance la plus grande possible au robot en ligne droite à la main
		- la mesurer précisement avec un mètre d_reel
		- relever la valeur en x de l'odo sur le robot (distance qu'il croit avoir parcourue) d_odo et en déduire le nombre de tics N_tics_odo
		- encore un petit produit en croix et on rentre les valeurs corrigées : N_tics_corr = d_reel * N_tics_odo / d_odo
		- itérer jusqu'à avoir la précision voulue


		Réglage de la distance entre les roues codeuses d_cod

		Première estimation:
		- mesurer précisement la distance entre les roues codeuses avec un mètre et la rentrer dans lib_asser_default

		Affinage
		- mettre le pic en mode debug pour pouvoir lire la distance parcourue
		- coller le robot contre un mur faire odo_init() pour initialiser l'odo à (0,0,0)
		- décoller le robot du mur, lui faire faire plusieurs tours sur lui même à la main et le recoller au mur
		- relever l'angle t_odo de l'odo (angle qu'il croit avoir parcouru en radians)
		- encore un petit produit en croix et on rentre les valeurs corrigées : d_cod_corr = t_odo * d_cod_odo / t_reel
		- itérer jusqu'à avoir la précision voulue


REGLAGE ASSERV

	Commencer par régler les valeurs max des vitesses et différentes accélérations.
	
	Déterminer v_max:
	Mettre les pwm moteurs a 100% et mesurer la vitesse atteinte grâce aux fonctions de debug.
	Fixer v_max à 90% de la vitesse obtenue pour avoir de la marge au niveau de l'asserve.

	Déterminer vt_max:
	vt_max = v_max / (distance entre roues codeuses / 2 )

	Déterminer a_max:
	Elle dépend de l'adhérence entre les roues et le sol, le poids du robot, ...
	Cf RCVA si on veut un calcul précis.
	Sinon 2m.s^-2 est une bonne approximation à pas dépasser.

	Déterminer at_max:
	at_max = a_max / (distance entre roues codeuses / 2 )

	Déterminer v_max*vt_max:
	Accélération centripète dont dépend la force centrifuge (Fc = ac * masse robot)
	Si elle est trop grande, le robot glisse perpendiculairement à la direction des roues codeuses et on ne sait plus où on est.
	Valeur safe : v_max*vt_max = 0.1g = 0.981

	On utilise un PI pour avoir une erreur statique non nulle mais pas de dérivateur qui introduirait de l'instabilité car la consigne (vitesse) est déjà la dérivée de la position.

	Ces limites sont purement physique et sont les valeurs maximales à ne pas dépasser.
	Dans la réalité on peut compenser la force centrifuge au niveau de l'odo pour éliminer cette contrainte.
	On peut bien sur rentrer des valeurs plus petites en fonction des caractéristiques du robot et de ce que l'on veut lui faire faire.

	
	Ensuite régler les PID de contrôle de la vitesse des moteurs.

	On utilise un PI pour avoir une erreur statique non nulle mais pas de dérivateur qui introduirait de l'instabilité car la consigne (vitesse) est déjà la dérivée de la position.

	On commence par la vitesse linaire. On utilise motion_linear_speed. On utilise le mode debug pour récupérer les valeurs des vitesses. On itère en augmentant le coefficient proportionnel jusqu'à atteindre le plateau de convergence. On augmente ensuite le coefficient intégral pour avoir une erreur statique non nulle et un temps de réponse intéressant sans oscillation.

	On passe ensuite à la vitesse angulaire. On utilise motion_angular_speed. On utilise le mode debug pour récupérer les valeurs des vitesses. On itère en augmentant le coefficient proportionnel jusqu'à atteindre le plateau de convergence. On augmente ensuite le coefficient intégral pour avoir une erreur statique non nulle et un temps de réponse intéressant sans oscillation.


	Enfin, régler les PID de commande de vitesse pour les déplacements.

	On utilise un PD pour avoir un comportement stable et sans dépassement.

	Le réglage est purement empirique. 

	On active l'asserve seulement en angulaire, on fait faire un demi tour au robot. On itère en augmentant le coefficient proportionnel jusqu'à avoir une oscillation amortie de 1-2 s. On augmente ensuite le coefficient dérivé jusqu'à ne plus avoir de dépassement.

	On active ensuite l'asserve seulement en linéaire, on fait faire 2m au robot. On itère en augmentant le coefficient proportionnel jusqu'à avoir une oscillation amortie de 1-2 s. On augmente ensuite le coefficient dérivé jusqu'à ne plus avoir de dépassement.

	
